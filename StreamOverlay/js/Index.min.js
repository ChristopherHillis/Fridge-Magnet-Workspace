

var width = window.innerWidth;
var height = window.innerHeight;
var imageCount = 0




let currentImage;
let currentImageIndex;

//creat stage needed for images
var stage = new Konva.Stage({
    container: 'container',
    width: width,
    height: height,
});

var connection = $.hubConnection()
var collabHub = connection.createHubProxy("CollabHubcs")
var _updating
//var json = stage.toJSON();

var layer = new Konva.Layer();

document.getElementById("clearCanvas").addEventListener("click", function () {
    stage.clear()
    stage.clearCache()
    stage.toJSON()
    // save stage as a json string
    //var json = stage.toJSON();
    layer.remove()
    layer = new Konva.Layer()
    //console.log(json);
})

document.getElementById("addText").addEventListener("click", function () {


    var textNode = new Konva.Text({
        text: 'Some text here',
        fontSize: 20,
        draggable: true,
        width: 200,
        id: String(imageCount)
    });
    var group = new Konva.Group({
        x: stage.width() / 2 - 200 / 2,
        y: stage.height() / 2 - 137 / 2,
        width: 200,
        height: 137,
    });

    textNode.on('transform', function () {
        // reset scale, so only with is changing by transformer
        textNode.setAttrs({
            width: textNode.width() * textNode.scaleX(),
            height: textNode.height() * textNode.scaleY(),
            scaleX: 1,
            scaleY: 1

        });
    });

    var tr = new Konva.Transformer({
        id: String(imageCount),
        // set minimum width of text
        boundBoxFunc: function (oldBox, newBox) {
            newBox.width = Math.max(30, newBox.width);
            return newBox;
        },
    });

    tr.on('transformend', function () {
        console.log('transform end');
    });
    textNode.on('dragend', function () {
        console.log("drag end")
    });

    tr.nodes([textNode])

    group.add(textNode)
    group.add(tr)

    layer.add(group);
    stage.add(layer);
    imageCount += 1

    textNode.on('transform', function () {
        // reset scale, so only with is changing by transformer
        textNode.setAttrs({
            width: textNode.width() * textNode.scaleX(),
            scaleX: 1,
        });
    });


    textNode.on('dblclick dbltap', () => {
        // hide text node and transformer:
        textNode.hide();
        tr.hide();

        // create textarea over canvas with absolute position
        // first we need to find position for textarea
        // how to find it?

        // at first lets find position of text node relative to the stage:
        var textPosition = textNode.absolutePosition();

        // so position of textarea will be the sum of positions above:
        var areaPosition = {
            x: stage.container().offsetLeft + textPosition.x,
            y: stage.container().offsetTop + textPosition.y,
        };

        // create textarea and style it
        var textarea = document.createElement('textarea');
        document.body.appendChild(textarea);

        // apply many styles to match text on canvas as close as possible
        // remember that text rendering on canvas and on the textarea can be different
        // and sometimes it is hard to make it 100% the same. But we will try...
        textarea.value = textNode.text();
        textarea.style.position = 'absolute';
        textarea.style.top = areaPosition.y + 'px';
        textarea.style.left = areaPosition.x + 'px';
        textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
        textarea.style.height =
            textNode.height() - textNode.padding() * 2 + 5 + 'px';
        textarea.style.fontSize = textNode.fontSize() + 'px';
        textarea.style.border = 'none';
        textarea.style.padding = '0px';
        textarea.style.margin = '0px';
        textarea.style.overflow = 'hidden';
        textarea.style.background = 'none';
        textarea.style.outline = 'none';
        textarea.style.resize = 'none';
        textarea.style.lineHeight = textNode.lineHeight();
        textarea.style.fontFamily = textNode.fontFamily();
        textarea.style.transformOrigin = 'left top';
        textarea.style.textAlign = textNode.align();
        textarea.style.color = textNode.fill();
        rotation = textNode.rotation();
        var transform = '';
        if (rotation) {
            transform += 'rotateZ(' + rotation + 'deg)';
        }

        var px = 0;
        // also we need to slightly move textarea on firefox
        // because it jumps a bit
        var isFirefox =
            navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        if (isFirefox) {
            px += 2 + Math.round(textNode.fontSize() / 20);
        }
        transform += 'translateY(-' + px + 'px)';

        textarea.style.transform = transform;

        // reset height
        textarea.style.height = 'auto';
        // after browsers resized it we can set actual value
        textarea.style.height = textarea.scrollHeight + 3 + 'px';

        textarea.focus();

        function removeTextarea() {
            textarea.parentNode.removeChild(textarea);
            window.removeEventListener('click', handleOutsideClick);
            textNode.show();
            tr.show();
            tr.forceUpdate();
        }

        function setTextareaWidth(newWidth) {
            if (!newWidth) {
                // set width for placeholder
                newWidth = textNode.placeholder.length * textNode.fontSize();
            }
            // some extra fixes on different browsers
            var isSafari = /^((?!chrome|android).)*safari/i.test(
                navigator.userAgent
            );
            var isFirefox =
                navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isSafari || isFirefox) {
                newWidth = Math.ceil(newWidth);
            }

            var isEdge =
                document.documentMode || /Edge/.test(navigator.userAgent);
            if (isEdge) {
                newWidth += 1;
            }
            textarea.style.width = newWidth + 'px';
        }

        textarea.addEventListener('keydown', function (e) {

            // on esc do not set value back to node
            if (e.keyCode === 27) {
                removeTextarea();
            }
        });

        textarea.addEventListener('keydown', function (e) {
            scale = textNode.getAbsoluteScale().x;
            setTextareaWidth(textNode.width() * scale);
            textarea.style.height = 'auto';
            textarea.style.height =
                textarea.scrollHeight + textNode.fontSize() + 'px';
        });

        function handleOutsideClick(e) {
            if (e.target !== textarea) {
                textNode.text(textarea.value);
                removeTextarea();
                console.log("text updated")
            }
        }
        setTimeout(() => {
            window.addEventListener('click', handleOutsideClick);
        });
    });

})

document.getElementById("file").addEventListener("change", ev => {
    const formdata = new FormData()
    formdata.append("image", ev.target.files[0])
    fetch("https://api.imgur.com/3/image/", {
        method: "post",
        headers: {
            Authorization: "Client-ID 460a923d166e2db"
        },
        body: formdata
    }).then(data => data.json()).then(data => {
        url.innerText = data.data.link
        console.log(data.success)
        if (data.success != false) {
            var imageObj = new Image()
            imageObj.src = document.getElementById("url").innerText
            imageObj.onload = function () {
                if (data.data.type != "image/gif") {
                    drawImage(this);
                } else if (data.data.type == "image/gif") {
                    drawGif(this)
                }
            };
        }
    })
})

function drawGif(imageObj) {

    var canvas = document.createElement('canvas');
    // use external library to parse and draw gif animation
    function onDrawFrame(ctx, frame) {
        // update canvas size
        canvas.width = frame.width;
        canvas.height = frame.height;
        // update canvas that we are using for Konva.Image
        ctx.drawImage(frame.buffer, 0, 0);
        // redraw the layer
        layer.draw();
    }



    gifler(imageObj.src).frames(canvas, onDrawFrame);

    // draw resulted canvas into the stage as Konva.Image
    var gif = new Konva.Image({
        image: canvas,
        width: 200,
        height: 137,
        draggable: true,
        id: String(imageCount)

    });

    gif.on('mouseover', function () {
        document.body.style.cursor = 'pointer';

    });
    gif.on('mouseout', function () {
        document.body.style.cursor = 'default';

    });

    var group = new Konva.Group({
        x: stage.width() / 2 - 200 / 2,
        y: stage.height() / 2 - 137 / 2,
        width: 200,
        height: 137,
        name: imageCount
    });

    var gifTransformer = new Konva.Transformer({
        nodes: [gif],
        centeredScaling: true,
        rotationSnaps: [0, 90, 180, 270],
        resizeEnabled: true,
        id: String(imageCount)
    });

    gifTransformer.on('transformend', function () {
        console.log('transform end');
    });

    gif.on('dragend', function () {
        console.log("drag end")
    });


    group.add(gif)
    group.add(gifTransformer)

    layer.add(group);
    stage.add(layer);
    imageCount += 1

    updateAnnotations()

}


function drawImage(imageObj) {

    var image = new Konva.Image({
        image: imageObj,
        width: 200,
        height: 137,
        draggable: true,
        id: String(imageCount)
    });

    // add cursor styling
    image.on('mouseover', function () {
        document.body.style.cursor = 'pointer';
    });
    image.on('mouseout', function () {
        document.body.style.cursor = 'default';

    });

    //layer = image
    var group = new Konva.Group({
        x: stage.width() / 2 - 200 / 2,
        y: stage.height() / 2 - 137 / 2,
        width: 200,
        height: 137,
        name: imageCount
    });

    //resize and rotate stuff
    var imgTransformer = new Konva.Transformer({
        nodes: [image],
        centeredScaling: true,
        rotationSnaps: [0, 90, 180, 270],
        resizeEnabled: true,
        id: String(imageCount)
    });
    imgTransformer.on('transformend', function () {
        console.log('transform end');
    });
    image.on('dragend', function () {
        console.log("drag end")
    });

    group.add(image)
    group.add(imgTransformer)

    layer.add(group);
    stage.add(layer);
    imageCount += 1


}

var menuNode = document.getElementById('menu');
var textMenuNode = document.getElementById('textMenu')

stage.on('contextmenu', function (e) {
    // prevent default behavior
    e.evt.preventDefault();
    if (e.target === stage) {
        // if we are on empty place of the stage we will do nothing
        menuNode.style.display = 'none';
        textMenuNode.style.display = 'none'
        currentImage = undefined
        return;
    }
    if (e.target.className == "Image") {
        currentImage = e.target;
        currentImageIndex = currentImage.id()
        // show menu
        menuNode.style.display = 'initial';
        var containerRect = stage.container().getBoundingClientRect();
        menuNode.style.top =
            containerRect.top + stage.getPointerPosition().y + 4 + 'px';
        menuNode.style.left =
            containerRect.left + stage.getPointerPosition().x + 4 + 'px';
    } else if (e.target.className == "Text") {
        currentImage = e.target;
        currentImageIndex = currentImage.id()
        document.getElementById("textColourChange").value = currentImage.fill()
        // show menu
        textMenuNode.style.display = 'initial';
        var containerRect = stage.container().getBoundingClientRect();
        textMenuNode.style.top =
            containerRect.top + stage.getPointerPosition().y + 4 + 'px';
        textMenuNode.style.left =
            containerRect.left + stage.getPointerPosition().x + 4 + 'px';
    }


});

document.getElementById('layerUpBtn').addEventListener('click', () => {
    if (currentImage != undefined) {
        var currentGroup = stage.find('#' + String(currentImageIndex))
        currentGroup[0].getParent().moveUp()
        menuNode.style.display = 'none';
        console.log("layer changed")
    }
});

document.getElementById('layerDownBtn').addEventListener('click', () => {
    if (currentImage != undefined) {
        var currentGroup = stage.find('#' + String(currentImageIndex))
        currentGroup[0].getParent().moveDown()
        menuNode.style.display = 'none'
        console.log("layer changed");
    }
});
document.getElementById('deleteBtn').addEventListener('click', () => {
    if (currentImage != undefined) {
        var currentGroup = stage.find('#' + String(currentImageIndex))
        currentGroup[0].destroy()
        currentGroup[1].destroy()
        menuNode.style.display = 'none';
        imageCount -= 1
        console.log("image deleted")
    }
});
document.getElementById('moveTopBtn').addEventListener('click', () => {
    if (currentImage != undefined) {
        var currentGroup = stage.find('#' + String(currentImageIndex))
        currentGroup[0].getParent().moveToTop()
        menuNode.style.display = 'none';
        console.log("layer changed")
    }
});
document.getElementById('moveBotBtn').addEventListener('click', () => {
    if (currentImage != undefined) {
        var currentGroup = stage.find('#' + String(currentImageIndex))
        currentGroup[0].getParent().moveToBottom()
        menuNode.style.display = 'none';
        console.log("layer changed")
    }
});

document.getElementById("deleteTextBtn").addEventListener('click', function () {
    if (currentImage != undefined) {
        var currentGroup = stage.find('#' + String(currentImageIndex))
        currentGroup[0].destroy()
        currentGroup[1].destroy()
        textMenuNode.style.display = 'none'
        console.log("layer changed")
    }
})

document.getElementById("textColourChange").addEventListener('change', function () {
    currentImage.fill(document.getElementById("textColourChange").value)
    document.getElementById("textColourChange").value = currentImage.fill()
    console.log("colour changed")

})

document.getElementById("fontSize").addEventListener("change", function () {
    currentImage.fontSize(parseInt(document.getElementById("fontSize").value))
    console.log("font changed")
})

function updateAnnotations() {
    if (_updating == true) {
        return
    }
    var jsonAnnotations = stage.toJSON()

    var collaborationSyncObject = {
        User: "Test",
        AnnotationJson: jsonAnnotations
    }

    collabHub.invoke("SetAnnotationSync", collaborationSyncObject)
}

collabHub.on("ReceiveAnnotationSync", async function (annotationSync) {
    console.log(stage.toJSON())
    stage.toJSON(annotationSync)
});

connection.start()

//add auto save